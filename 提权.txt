	0.我们希望在获取UAC的权限同时不触发UAC弹框
	1.注册表提权： 需要有权限能修改注册表中的敏感项   F键复制 
		　net user gslw$ test168 /add
		第一步：打开注册表编辑器，定位到HKEY_LOCAL_MACHINE\SAM\SAM项。由于默认情况下管理员组对SAM项是没有操作权限的，因此我们要赋权。右键点击该键值选择“权限”，然后添加“administrators”组，赋予其“完全控制”权限，最后刷新注册表，就能够进入SAM项下的相关键值了。
　　		第二步：定位到注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users项，点击“000001F4”注册表项，双击其右侧的“F”键值，复制其值，然后点击新建的注册表项(该项值最大)，双击其右侧的“F”键值，用刚才复制键值进行替换其值。
		第三步：分别导出gslw$、00000404注册表项为1.reg和2.reg。在命令行下输入命令"net user gslw$ /del"删除gslw$用户，然后分别双击1.reg和2.reg导入注册表，最后取消administrators对SAM注册表项的访问权限。
　　		这样就把gslw$用户提升为管理员，并且该用户非常隐蔽，除了注册表在命令下及“本地用户和组”是看不到的。这样的隐藏的超级管理员用户是入侵者经常使用的，对于一个水平不是很高的管理员这样的用户他是很难发现的。这样的用户他不属于任何组，但却有管理员权限，是可以进行登录的。
		//RootKit隐藏：我们隐藏注册表键值只需其中的两个文件，hxdef100.exe和hxdef100.ini。其中hxdef100.ini是配置文件，hxdef100.exe是程序文件。打开hxdef100.ini文件定位到[Hidden RegKeys]项下，添加我们要隐藏的注册表键值gslw$和00000404即用户在注册表的项然后保存退出。然后双击运行hxdef100.exe，可以看到gslw$用户在注册表中的键值“消失”了，同时这两个文件也“不见”了，在任务管理器里面也看不到hxdef100.exe进程。不过用了扫描工具后会找出可疑进程，结束掉“问题”进程那么RootKit隐藏就被解了。
	2.借助二进制漏洞(传统的本地漏洞思想)，利用大马，攻击已有高权限程序，进行提权
	3.用户账号登录系统的时候会被给予代表权限的令牌（随机数），和访问web系统一样的说。
	  windows 里System可以算是最高权限，但是它不包含所有Administrator和Usere的权限。也就是说与Administrator是个交集。Administrator包含了User、Guest。
	  Linux下权限设置简单，就root和user。root包含user。

	  除了用户账号，还有服务账号，就是开机启动的服务用哪个账号来描述自己的归属。
	  
	4.神秘提权超强版冷枫去后门webshell支持serv-U和udf.dll提权。
	5.使用bypassUAC来提权，在msf中有模块，在github上有项目。在windows基本还是借助UAC来实现的。
	6.hash dump
	进入C:\Windows\System32\config找不到原来的SAM文件，就从C:\Windows\System32\config\RegBack处拷贝一个SAM到config内。一定可以的办法就是进入另外的系统。
其实存在直接绕过系统密码的工具：
	BootRoot 2005黑帽的一个项目，我没有测试过，有兴趣的可以自己点链接了解一下。
	SysRQ2    这款可以绕过Vista以下的系统。
	Kon-Boot 首推这款工具，目前国内的WinPE有不少已经自带了，我在实际中也经常使用这个，目前最新版本可以绕过全Windows系列，Mac OSX部分，Linux部分。收费版，网络上有破解。 
或者重置系统密码：
	kali中自带了一种工具，但是笔记不知道记录到哪里去了
部分工具可以通过一些技巧来在没有权限的情况下获取hash。如果已经有权限了，那么就有很多工具可直接导出hash：
mimikatz
WCE.exe
	cain的Crack->LM & NTLM Hash已经不能支持对win10的hash dump，即便有着管理员权限。
	7. 安装Everything Search engine这款工具的时候，给了我一点提示，安装的时候可以选择是安装服务还是 安装 每一次开启使用管理员运行（每一次运行的收都会触发UAC机制）。哪一个更加安全，我也不是很好说，估计应该是每一次点击exe文件的时候进行UAC询问比较好。







------------------------------------------------------------------------------------------------------------------------
linux中的
	1.race condition：  成功就是winning the race
	在其他程序获取特权之后，放弃特权之前，利用这个机会，来为自己谋取特权。
	典型例子：CVE-2011-1485（CNNVD-201105-153） 漏洞原因是因为pkexec和polkitd守护进程中存在资源竞争，没有检查pthread_mutex_lock的返回值，于是代码一直卡在那里。通过执行特定的C程序就能直接利用之前的setuid来称为uid为0的root。
		FTP服务器是按照执行用户的权限来执行的，如果用户数据意外关闭了就回产生socket的SIGPIPE信号，于是进程就回跳转到dologout(）中，并将自己的权限提升到uid=0，然后写入系统日志。但是你可以通过发送SIGURG信号，在ftp服务器试图关闭掉用户的时候，通过中断，迫使它跳回到服务器的主命令区。

	2.dump core 的输出文件中有时候会有shadow文件中的部分内容。
	这种文件处理漏洞早期是在一个ftp服务器上发现，登录到ftp服务器之前先发送一个PASV命令（客户端处于内网，被动连接），这会导致该ftp服务器将一个全局可读的core文件写到文件系统的根目录汇总，这个文件中含有shadow文件中的部分内容。通过ulimit -c 0设置为0，这在kali中已经是默认的了。
	3.共享函数库 就是dll一样，节省了系统硬件和内存空间
	（1）在原来的位置上修改库
	（2）修改环境变量LD_PRELOAD，引用自己的库。 而修改环境变量说来也有点逗，因为有些版本的in.telnetd允许用户在试图建立一个连接的时候将环境变量传递给远程系统。这时候的解决办法是：动态链接器应该在链接SUID为root的时候，忽略这个环境变量，但是这个链接器只能靠gcc他们改变源码了。
	4.来自内核的缺陷：
	有几个版本2.6.39等内核中的mem_write函数在写入/proc/<pid>/mem的时候，并没有验证调用权限
