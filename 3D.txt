计算机图形学各个领域的目标或许不同，但最终的形式都是渲染(即绘制)在二维的显示设备上的图像。
MFC没饭吃，千万不要碰。反正都要在windows上写GUI了，还苦逼的用什么C++，就该去用C#。每一个语言都有每一个语言该做（适合做）的事情。C#可以配合不少游戏引擎来使用，比如说unity。windows下wpf/C#（反正写界面程序推荐C#）,我用qt是为了快速开发与方便跨平台。在Windows上都用XAML，他有不同的名字，譬如说WPF，Silverlight，Metro，Universal等，都一样。wpf是界面编写库，非常不适合写游戏，小游戏都会很卡。
CAD(Computer Aided Design，计算机辅助设计），可以从来制作3D模型。推荐使用3dmax、maya、blender（开源免费版），或者上手更加简单的sketchup（简称su，当然存在不小的差距）。
3D Studio Max，常简称为3d Max，是基于PC系统的三维动画渲染和制作软件。
微软Paint3D 是款3D绘图软件。
HORI 3D Printer 是3d打印所需要使用的软件

书籍：
OpenGL超级宝典 蓝皮书
OpenGL编程指南 红皮书（用于参考）
WebGL编程指南  three.js学习之前最好看一下
3D文件格式：
.js	.obj	.unity	.3ds
obj是3D模型文件格式（不包含动画、材质特性、贴图路径、动力学、粒子等信息），文件中按照一定格式与语句包含大量的数字来描述定点、边、面等，这种文件

3D库:openGL OIV（open inventor）  VTK（这是openGL的再次封装） DirectX（用于游戏实现，不过这是微软公司特有的） XNA（对DirectX再次封装），也因为增加了封装，比直接调用DirectX要臃肿和缓慢
openGL是面向过程的，OIV是面向对象的,同样的实现，OIV的代码可以做到最短，据我所知是所有图形库中最短的。
OpenGL的库：GLC_LIB  Assimp(Open Asset Import Library )

3D渲染算法有好几种，这也关系到了投影到平面的时候是什么样子。
为了简化模型碰撞检测，将每一个模型的边界设定为一个长方体。


术语：
之所以人能看3D主要是因为两只眼睛看到的图像不一样，然后大脑进行合成。如果透过一只眼睛来看东西，那么大脑还是会尝试3D化，但是很明显你的距离感已经不太好了。随着物体逐渐边缘，图像之间的角度也会越来越小。我们可以通过加大两幅图像之间的角度来增强3D效果，3D电影就是采用了这种方法（为了能达到过度的效果，这种方法可能会让不少人觉得头晕）。
要想二维图像产生3D的效果的方法叫做透视Perspective，有色彩透视，线性透视（比如说线构成的立方体）。不过《OpenGL超级宝典》中说透视效果加上颜色的改变、纹理、光照等共同组成了3D的效果。
通过变换矩阵进行位置上的旋转等变换。
通过投影矩阵投影到摄像机上（屏幕上）。透视投影图是从某个投射中心将物体投射到单一投影面上所得到的图形（估摸着使用了投影面的法向量）。
光栅化：绘制定点之间的像素来形成线段
着色器:加颜色与贴图的东西。最终得以渲染。
程序里面超量的渲染会导致程序的崩溃
由一点放射的投射线所产生的投影称为中心投影，由相互平行的投射线所产生的投影称为平行投影。平行投射线倾斜于投影面的称为斜投影，平行投射线垂直于投影面的称为正投影。透视投影就类似于斜投影。


OpenGL的做法真的很好，既是一种标准，也允许行业竞争的存在。允许提供商通过扩张机制进行创新：1.能向OpenGL API增加开发人员可用的新函数；2.可以添加能够被已存在的OpenGL函数是别的标记Token或者枚举。从前游戏需要为特定图形卡进行重新编译。不同的商家会有不同的扩展标识：比如NVIDIA就是NV_，IBM就是IBM_，ARB（管理opengl的商业组织）就是ARP_，Microsoft就是WGL_，ATI Technologies就是ATI_......厂商之间的竞争就是性能、图像质量和驱动程序的稳定性之间的竞争。
对OpenGL的实现可以是方便人们调用的函数库，也可以是一个用于完成三维图像渲染任务的硬件设备的驱动程序包。
OpenGL3.0将不少2中的特性标记为“不鼓励使用”，在OpenGL3.x中移除了这些特性。
OpenGL辅助函数库，似乎用来写GUI，从AUX-》GLUT（opengl utility toolkit）-》freeglut
GLEW 自动初始化新函数指针并包含所需类型定义、常量和枚举值的扩展依赖库。
GLTools 基于GLEW，包含一个用于操作矩阵和向量的3D数学库
OpenGL也可以用来写2D程序，用于渲染。

为了做到良好的可移植性，定义了自己的数据类型，所以可以与大部分语言、平台搭配。我这里省略GL开头：
boolean 
byte ubyte
short ushort
int uint 32位
int64 uint64
sizei/enum/uint 无符号32位整数
half 最少位宽16 半精度浮点数
clampf [0,1]范围内的32位单精度浮点数
clampd [0,1]范围内的64位双精度浮点数
float 32位浮点数
sizeiptr 无符号整数本地指针大小
intptr 有符号整数本地指针大小
sync 同步对象句柄本地指针大小
char 至少位宽8 字符串

glGetError（）来获取当前错误标识，获取以后这个全局变量会被清空。没有错误就是GL_NO_ERROR
GL_OUT_OF_MEMORY 没有足够的内存.....等等

const GLubyte *glGetString(GLenum name) #返回版本号与厂商的有关信息

void glHint(GLenum target, GLenum mode) opengl的实现常常包含两种方法，分别偏向于速度或是图形质量。target指定希望进行修改的行为类型，mode告知我们关心的是哪个方面。
