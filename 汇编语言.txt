	0. MASM是Microsoft Macro Assembler 的缩写，是微软公司为x86 微处理器家族开发的汇编开发环境，
	1.debug命令只支持32位操作系统，所以要在64位系统上使用就要借助DosBox这个软件。下面稍微介绍下DosBox的使用：
	  DosBox就是模拟一个Dos系统，和书上讲的一样可以Alt+Enter最大化。已经绝种的Debu命令居然可以传输文件
	2.又一次查看到一条命令是
???  地址
	  也就是无法识别，执行了下，发现Dos一直在那里运行，出不来了。
	3.如果你每一次开启Dos都是为了debug命令，那么不妨双击DOSBox 0.74 Options.bat，这个bat会用notepad.exe（就是记事本）打开DosBox.exe的配置（DOSBox.exe -editconf notepad.exe -editconf %SystemRoot%\system32\notepad.exe -editconf %WINDIR%\notepad.exe），我们在最后面的autoexec中加入想要一运就自动执行的命令:，我改了之后样子长这样：
[autoexec]
mount c e:\dos #直接记录了这时候文件的情况，结合第七点
c:
cls
#在这个文本中是#表示注释，汇编里面是;表示注释
	4.Debug Dos还可以调CPU速度。真厉害！Ctrl+F11和F12。
	6.汇编的思想和一般的编程语言里面的思想是一样的。“函数的模块化”、传参等等，理解汇编的时候就要和高级语言合在一起理解。
	7.在DosBox的那个运行文件夹下加了一些新的exe，但是要重开这程序才可以，说明他只是把本机的情况读取了然后就独立运行了。
	8.除了自己DosBox+debug32（debug）+masm+link等等exe程序，对于汇编还可以直接使用一种叫masm for windows的集成程序，他就是把上面提到的集合了（它的调试就是debug或者cv），有一个好处就是可以告诉你错在哪里，就像IDE一样。有一个小毛病：点了运行，但是迅速关闭（这时候却已经先删除了原有exe）。还有按了g以后用r查看怎么寄存器的数值都没有按照程序变化，一开始几条改变ds、ss不能用g只能用t。代码文件的保存不确定，自己关闭前要注意先复制好代码。
	9.一个没有退出的程序，也就是没有:
mov ax,4c00H;debug里面必须没有H，但是文本汇编程序里面必须要有H（只能识别十六进制还要带上H）
int 21H
导致在debug下（由于是模拟实模式，所以就一直执行下去而不停止，这时候没有C-C这种停止进程的方法，因为没空执行你的C-C）；在masm for windows下就会导致出现的DosBox未响应，然后自己关闭了，而且默认独自占用一个逻辑核，不像正常的DosBox那样可以自己调分给他的CPU资源。

	 刚刚进去的时候，如果是masm for windows的debug调试那么ax=FFFF，就是刚开机指向BIOS，debug进去则是ax=0000
	10.写颜色程序的话，建议在源代码模式中写，因为除了全屏下的第一行（可能还有行是这样）不会被debug中的字符滚动而干扰，避免产生意想不到的结果，非全屏还是会被干扰，不过非全屏行和列关系好理解。不过在masm for windows中，如果不给你的输出字符设置颜色而使用自带的07H这个无闪烁无高亮黑底白字，那么最后是无效的，看到的只有Press any key to continue。这也是个masm的问题。

我想要寻找用汇编语言的方式去更改从前写的汇编指令，也就是让a命令回到某个地方。
	11.寄存器名字加了E（Extend）就是32位寄存器。
	12.位宽修饰符的使用:（在没有寄存器的时候靠它来指定长度）
CMP WORD PTR [SI]，3
add byte ptr VAR,1
	13.双操作数指令，如果没有加上位长度的指示，不能一个是内存一个是常量（也就是不能两个操作数都是内存）。可以是一个内存一寄存器，这么想，对于加法可以是寄存器加到内存上，那么说明存在这条通路，那么反一下也是可以的。
	14.乘法溢出的问题可以转换为循环加法来解决，而这时候要解决的就是加法溢出问题（建议把数字存内存里，要加再取出来加低八位），加法溢出问题位数要求不高可以借助adc这个指令。这是个十分愚蠢的办法，因为乘法的最大支持在8086里面是两个16位寄存器的相乘，所以要是用循环和加法来解决问题是很不好的。想了下对32位乘法的实现，发现转为16位乘法，然后用可以处理溢出的加法进行移位后相加处理。
	15.写一个允许32位除以16位的除法汇编程序：
		首先明白最终结果：商需要16位，余数也要16位进行存储。
		把它拆分成两个字节，高位高位运算，低位低位运算。分别得到高位的除数与余数，低位的除数与余数，存放在堆栈里面。下面就是要看一下这些余数是不是还可以合起来除以除数，很明显是可以的，因为真正的余数是要小于除数的，所以余数应该起码是16位，但是这里面存在的高位的余数。这时候要算的还是一个32位除以16位。
		接下来明显不能再这样去计算，因为高位与低位都是除数的余数，所以不可能再被除数除掉。现在要做的第一件事就是要把高位的余数变成0。我们把高位的余数转化为低位的余数，是之可以再次参加除法，高位其实在我们看来就是低位的最大值0xffff加一。假设高位余数是a，低位余数是b，这样子就先转换为a个0xffff和(a+b)个1。0xffff除以除数，将商和余数再乘以a，得到的乘积也就是一部分商直接加到之前计算出来的商里面（由于之前高位余数是小于除数的，而除数与商的乘积小于等于0xffff，所以乘积不会超过16位）。如果除数接近16位所能表示的最大值的1/2那么余数是很大的，也就是接近最大值的1/2。这样子a乘以余数就需要使用16位乘以16位这样的乘法。进位之后所得到的的又会是一个新的高位余数，和一个低位余数，但是高位余数经过除法以后会变小，所以要在按照之前的进行计算，直到高位余数是0，低位余数这时候再加上去可能出现溢出，所以每次低位加了以后对高位余数使用adc指令。最后还要再进行一次除法使得确保低位余数是小于除数的。
	16.
;?的作用
DATAS SEGMENT
    ;此处输入数据段代码  
    DW 40 dup(0805H)
    DD 16 dup(?);我发现第六行如果不给他值的话就会自己有值，但是?却是会将之全部变成0
DATAS ENDS

STACKS SEGMENT
    ;此处输入堆栈段代码
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START
	17.push结合retn这种返回指令可以实现指定跳转。（就是借助返回机制来实现对CS：IP的更改）
	18.意外地发现masm for windows这款软件对目录的支持不太好，我安装在一些目录就有许多功能无效，关闭程序的时候就会弹框说路径错误。最后发现似乎只有安装在C盘才有效。。。这个问题之前没遇到过。。。真是神了。可能是因为win10的原因。
	19.Masm for windows里面如果数字后没有跟着H的话，汇编IDE自然认为它是十进制的。debug中数字被志杰认为是十六进制。
	20.IDE中and ah,255-15;就是and ah,fOH。我的意思是他会u自动计算减法，debug中也是这样在a指令存入的时候会自动计算减法。
	22.loop的时候是先(cx)=(cx)-1，如果(cx) != 0才转跳~否则就执行下面的命令。要明白他就是个do-while。
	23.0b800H是文本模式下的显存位置，0a000H是图形模式下的显存位置（定义更加丰富）。我们使用的是0B800H-0BFFFH，一共显示8页，每页2000字，每一行可以放下80个字，也就是说总共有25行（其实相当于每一页少了96字节，用总的地址去算）。
	24.dosbox不支持E:\"Program Files (x86)"\dos这种使用双引号括起来的路径
	25.debug里面空格的多少不影响汇编命令
	26.都是mov，但是指令长度不一样：
0770:0100  MOV    AL, 1
0770:0102  MOV    SI, 2
0770:0105
	27.debug里面一开始还是会遇到其他命令的，我本还以为只会遇到0000   ADD   [BX+SI],AL。
	28.debug中u命令显示十六条命令。
	29.g命令后面有没有数字参数一个效果，都是一直执行下去。所以如果后面没有退出指令，那么就会导致debug陷入一直执行的状态。不过-g  XXXX:XXXX       连续执行到断点位置
	30.右移操作就会导致AF为1(其实应该讲做不确定)。
	32.test是只改变标志寄存器的and，cmp是只改变标志寄存器的减法。
	33.mul 1是错误的，1(立即数)的长度不可以判断。所以要先把1给通用寄存器。被乘数默认是al或者ax。mul是单操作数指令。
	34.写入内存的指令可以用push，也可以用mov。还有串指令
	35.段寄存器ds:[2]或者ds:2，就是不能ds[2]。
	36.mov es:[9*4],ax可以执行。使用[9*4]其那面必须要指明段，加法也是一样。
	37.突然发现assume于masm for windows是放在代码段里面。而且必须要有个start来指明代码段起始位置，否则就会执行了其他指令。 但是有些时候又正常，简直是傻逼。
	39.IF标志只影响外部中断请求是否响应，不影响对内部中断的响应。程序执行 INT n 指令是内部的软件中断。不管 IF 是0还是1，只要程序运行遇到 INT指令，都会执行。
	40.debug会出错比如说有中断一直按T（应该按G），但是直接运行没问题，程序应该是没有问题的。masm for windows中“生成可执行文件”，只要没有报错就会自动关闭。
;16中断例程的0号子程序会读入字符到al
DATAS SEGMENT
    ;此处输入数据段代码  
    db 10 dup(?)
DATAS ENDS

STACKS SEGMENT	
    ;此处输入堆栈段代码
    dw 8 dup(?)
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
   
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    call function
    

 
    MOV AH,4CH
    INT 21H
    
function:
	mov bx,0
read:
	mov ah,0
    ;bx用于计数
    int 16H  #16中断例程的0号子程序会读入字符到al
    mov ah,al 
    cmp ah,13
    jz null
r:   ret
    
null:
	mov dx,4
	jmp r
    
CODES ENDS
    END START
	42.db 5 dup(61,07)
	43.通过这个程序可以知道小键盘的键码是特殊的，我这里取的已经是键盘缓冲区里面的ASCII，不会立即回显。print函数写得不错。
DATAS SEGMENT
    ;此处输入数据段代码  
    db 10 dup(?)
DATAS ENDS

STACKS SEGMENT	
    ;此处输入堆栈段代码
    dw 8 dup(?)
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
   
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    call function
    mov ax,0
	mov si,ax
	mov di,ax
	mov ax,0b800H
	mov es,ax
	mov cx,5
    call print

 
    MOV AH,4CH
    INT 21H
    
function:
	mov bx,0
	mov cx,5
	mov dx,07
read:
	mov ax,0
    ;bx用于计数
    int 16H
    mov ds:[bx],al
    inc bx
    mov ds:[bx],dx
    inc bx
	loop read
    ret
    
print:
	movsw
	loop print
	ret
    
CODES ENDS
    END START
	44.di，si不是段寄存器，可以直接给常量。默认DF一直为0，di、si处于递增状态。可以直接对di、si使用add命令。pop si也是正确的。
	45.ds:[si]是正确的，ds:si和ds[si]是错误的。
	46.ah会在8位mul中改变
mov ax,1111H
mov bh,2
mul bh
	47.masm for windows里面改了程序就要重新生成debug，否则会出现神奇的命令（有着TM神奇的效果的命令）。masm for windows是个神奇的环境，debug里面通过g来直接略过中断（如果有中断还是用t就会导致程序回不来，我也不知道为什么），我这次还碰到一个傻逼问题，运行结果和我猜测不同，看了很久没看出来，后来发现debug中用了g运行结果和我的猜测一样。
	   mdzz，刚刚明明保存下来了，结果打开来又不知道是什么
	   
	   现在masm 又一下子好起来了。
	48.
;堆栈的使用
DATAS SEGMENT
    ;此处输入数据段代码  
DATAS ENDS

STACKS SEGMENT
    ;此处输入堆栈段代码
    dw 3 dup(?)
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    mov ax,STACKS
    mov ss,ax
    mov ax,2*3;注意这里的数值
    mov sp,ax
    ;此处输入代码段代码
    call fun
    
    

    MOV AH,4CH
    INT 21H
fun:
	mov ax,1
	ret
CODES ENDS
    END START
	49.OF是16位FR中第二个四位的最高位
	50.汇编语言判断最高位是不是1：
1.与运算判断，test命令然后看ZF
2.左移判断CF（对应使用JC）
补充：add al,0  然后使用基于SF的跳转JS JNS。

 	   判断最后一位是否为1
1.使用对2的div除法（余数会在ah里面）
2.联合CF的移位
3.与运算，test
2.1.是因为位置的特殊才有的方法。
	51.设置了for的标号，后来可以使用FOR。标号的大小写也是随意的。不清楚为什么，我现在怎么设置都设置不了for标号。
	52.计算10个数字里面的奇偶个数的时候，可读性好的算法是只对奇数或者偶数进行计算（一般数奇数，直接一直add最后一位的值就好），因个数固定最后使用减法求得偶数个数。
	53.似乎标号不能叫for、while.
	54.对于函数部分，可以使用PROC ENDP，就相当于是一个更显目的表示。
xxxx PROC FAR （如果有FAR那么call 的时候就相当于是call far ptr xxx）


xxxx ENDP
	55.PF标志位是指得到的结果中为1的位的个数是奇还是偶数。偶数时为1。
	   AF 在发生字单元操作的时候，低字节向高字节借位或者进位。字节操作的时候，低4位向高4位进位。这两种情况会置为1。
	56.立即数是常数，必定是由寄存器输出的，由存放在ROM中的数据译码得到。所以可以sub [si],64但是这条指令会因为没有指明类型而报错。不过从查看指令来看，明明立即数就是在内存的指令中的，比如mov bx,1 就是bb0100。
再次补充：使用立即数的时候要注意是否要加上类型。
	57.SP,BP一般与段寄存器SS 联用，以确定堆栈寄存器中某一单元的地址，SP用以指示栈顶的偏移地址，而BP可 作为堆栈区中的一个基地址，用以确定在堆栈中的操作数地址。
	58.在8086中push是减，pop是加。
	59.mov byte ptr 1[0],0A0H 立即数能一个 ;这个格式是错误的，因为使用了+法，所以应该用ds:1[0]
	60.并不是所有的[xx]都是默认ds:，比如说bp借助ss。（不存在[sp]）
补充说明：这条指令使用了基址寻址，但是mov byte ptr [bp],0A0H这条指令并没有，bp本身就是基址寄存器，他还需要一个立即数什么的才能算是基址寻址
	61.masm 可以直接识别 2F。后面不需要有H？不不不，2F虽然可以编译通过和执行但是被当做23.
	62.masm 中81H前面不需要有0也就是081H，但是C1需要有。MASM 规定以 A - F 开头的数字都应在前面加个0
	63.细谈OF溢出问题：
判断标准：最高位进位/借位 异或 次高位进位/借位
0+80 OF=0 #0加上或者减去任何数都不会使OF=1，由上面判断标准可知
1+7F OF=1
0-80 OF=0
1-81 OF=0
计算机内对于减法是将数字求补以后相加。0-80 即 0+80从有符号数范围判断然后发现这样其实是有溢出的？80如果当做正数的话，是存在溢出，但是80H其实只是二进制的表示，所以很明显这时候应该看成负数，所以没有溢出。
除了0+80，还有1+80,2+80....

综上，我原本那种转化为十进制，然后判断范围来判断是否溢出是对的。毕竟这很符合溢出的定义。
	64.有一些运算会在复杂设备的接口中完成（像个小型电脑）
	65.标志寄存器FR Flag Register或者称为PSW Program Status Word。
	66.会有一些特殊的写法
基址寻址：
BX/BP（基址分量） + 常量
[BP]100H  <=>SS:[BP+100H]
变址寻址：
SI/DI（变址分量） + 常量
[BP][SI]0020H <=>ss:[BP+SI+2000]
[BX][SI]0020H <=>ds:[BX+SI+2000]

002[si]

位于端口中的数据均是端口寻址方式。
对内存单元的隐含使用就是隐含寻址。 #寻址就是在逻辑内存上寻找数据的地址。

单操作数指令不能进行立即数寻址。但是可以基址、变址寻址    所以inc byte ptr [0]是错误的


	67.要使用堆栈，一开始要设置好bp，sp的值。考虑到8086 push是先减小地址然后存入，所以对于dw 10 dup(?)，申请范围是0-19所以应该设置sp为20。
	68.mov ax,cs:[5-cl] 5-cl是不可以的。
	69.写子程序涉及到了：
push bp
mov bp,sp
pushf
push ax
push bx
push cx
..


pop ..
popf
pop bp

现场：当主程序调用子程序的时候，有关寄存器、标志位当时的状态被称为现场。有一个词叫现场保护。这个在期末考里占分。
	70.?的真正意思是要了空间但是没有赋值，不过实际使用中就是赋值0.
	71.伪指令：
two equ 2
two = 2

LABEL用来设置或者更改变量或者标号的属性
BYTE 对应1
WORD 2
DWORD 4
NEAR -1 #上面三个变量类型，下面三个标号类型
FAR -2
使用：
WVAR word 12
wvar label dword
除了使用label，还可以用equ this来达到一样的目的

num dw 12
mov cx,type num #type是类型属性运算符，会把0002表示word类型给cx

强制类型转换符PTR

a dw 10 dup(?,?)
len equ length a ;len = 10 ; $-a
s equ size a;a = 20

	72.
inc、dec不会对CF影响，用来自己构造循环的时候就和loop一样（不同的是。。loop是不影响所有标志位。。）
loop不影响FR。
	73.masm支持'a'，dup('Good!')
	74.标号和变量的共同性质
SEG段属性运算符，指示编译程序返回变量或者标号操作符所在段的段基址。
偏移量属性运算符OFFSET
	75.debug中t 0会报错
	76.支持+ - * / mod算术运算符，eq ne lt gt le ge关系运算符
high 表达式 获取高八位
low 表达式 获取低八位

优先级：
length size
ptr seg offset type this
* / mod shl shr ;不知道为什么
high low
+ -
eq ne lt le gt ge 
not ;注意一下这里not优先级很低
and
or,xor
	77.
datas segment
wvar dw 0012H,0034H
datas ends

wvar就是[0]
wvar+1就是[1]
	78.段命名
段名字 [对齐类型][组合类型][类型]

段名字 ends

对齐类型：
BYTE 从未占用的下一个字节开始<=> 没有
WORD 从未占用的下一个字开始 ，起始地址要求是偶数
DWORD 从未占用的下一个双字开始 ，起始地址第二位要求是0
PARA 从未占用的下一个节（16字节）开始 ，起始地址第四位要求是0
PAGE 从未占用的下一个页（256字节）开始 ，起始地址第八位要求是0

组合类型：告诉程序怎么把不同模块中段名一样的段
none 表示当前段独立于其他模块，这也是默认的
public 表示当前段和其他模块中段名相同的public类型段组合成一个段
common 表示当前段与其他模块中同名段重叠，前一同名段数据会被覆盖
STACK 表示是堆栈段，组合情况和public一样。
AT 数值表达式  会以数值表达式的值作为前段的起始地址

类别是一个由程序员按标识符规则设定的带单引号的字符串;连接程序将类别名相同的短组合起来在存储器中连续存放。

	79.assune 是指定关系，如果有CS、SS（如果对应段类型被指定为stack）才会被初始化。在向内存中装入程序的时候ds，es有其他用途所以只能在用户程序中进行初始化。
	80.masm最后面end start指明了他是一个不同的“标号”，其实也就是告诉程序把这个标号所代表的的地址给IP。
	81.子程序：
子程序名字 [near/far]
	...
子程序名 endp
	82.
VAR2 dw 12,13,14H
len equ $-var2
	83.int指令先存FR-》再CS-》再IP。居然有个对应的iret。                             84.输入输出的系统调用：
没想到除了用0b800-0bfff来输出来可以使用中断指令，而且有按照字符串而不是字符来进行输入输出的中断。
补充说明：子功能程序号不视为入口参数

单个字符的输入
mov ah,01
int 21  #出口参数al，就是输入的asc码

单个字符的输出
mov ah,02
int 21 #入口参数dl

字符串输入
mov ah,0ah
mov dx,缓冲区起始偏移量
int 21h #DS:[dx]为缓冲区首字节，存放的是你设置的最大输入字符个数。ds:[dx+1](不要写成ds:[dx]+1)这里会自动存入实际读取的字节数。之后的缓冲区就作为存字符串的地方。
配合使用指令：lea dx xxxx


字符串输出：
mov ah,09
mov dx,字符串起始偏移量
int 21h

(ds):(dx)=字符串首字节地址 //以$结尾


	85.BH是BH寄存器，而0Bh是十六机制值。
	86.sal和shl等价，移动会把符号位也动了。
	87.段基值：逻辑地址的一个组成部分，用于指示一个段在内存中的起始地址。它乘以16以后就是段基址。
	88.逻辑运算指令中，除NOT指令外，CF、OF均置0，AF为不确定
MOV  AL，0F3H
MOV  DL，0C4H
ADD  AL，DL
AND  AL，0FH

执行上述程序片段后，（AL）=    07H     （1分），（AF）=    不确定     （1分），
CF=      0     （1分），OF=     0      （1分），PF=     0      （1分）
	89.移位指令中，当指令的移位次数大于1时，OF为不确定
	90.
1．	逻辑地址
在CPU内部的存储单元地址表示形式，分为段基值和偏移量两个组成部分，它们都是16位的，在指令或源程序中只能使用逻辑地址来表达存储单元。我还以为是程序执行时分配的内存空间，物理地址是实际地址，汇编里面的定义sb。

2．	物理地址
CPU访问存储单元时向地址总线传送的地址表示形式，是20位的地址，由逻辑地址中段基值乘以16再加上偏移量得到，逻辑地址到物理地址的转换由CPU在执行访问存储单元的指令时自动完成。
	91.
DATAS SEGMENT
    ;此处输入数据段代码  
DATAS ENDS

STACKS SEGMENT
    ;此处输入堆栈段代码
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
START:
    MOV AX,DATAS
    MOV DS,AX
    ;此处输入代码段代码
    mov al,80h
    sal al,1
    
a Proc #按顺序执行会进行调用，但不同于call，因为按照指令来看就是顺着的
	mov ax,1
a endp
    
    MOV AH,4CH
    INT 21H

CODES ENDS
    END START
	92.控制标志位用于标识运算指令执行后运算结果的特征，用于控制CPU的工作模式或改变CPU对某些事件的响应方式。
	93.中断过程：中断请求、中断响应、中断处理、中断返回
	94.回车换行是0D、0A。用int 21h的02h进行输出。
	95.BCD码有两种划分：组合型Packed、非组合型Unpacked
用四位二进制来表示一个十六进制，就是Packed
虽然用四位二进制来表示一个十六进制，但是字节的高四位不使用，就是Unpacked。
	96.|*****|*****|*****...这种循环字符串很适合用串指令来实现。
	97.将块A中的偶数字节搬到Dest块中这个问题：
需要分四种情况考虑，是否重叠与谁在上谁在下。
	98.
有符号整数比较大小的时候：
CF =0 大于等于 
CF =1 小于
继续判断需要使用SF
	
无符号整数：
OF=SF 大于等于（要求相减结果大于等于0，结果可能溢出）
OF=/=SF 小于
	99.
移位指令对AF标志位的影响是不确定的。
sal指令对CF的影响，看最后一位移出来。
对于OF的影响，看符号位是否在移动的时候改变，所以如果移动位数大于1，就是不能判断这次移位是否溢出，认为值不确定。
sar指令始终OF=0。

shl指令，在汇编系统里面两者是不同的名字，但是在实际8086里面两者是相同的指令。
shr如果造成符号位编号就会导致让Of=1，前提是指移动一位。移动多个位认为值不确定，我估计是因为检测电路只能检测上一位和这一位之间的变化（只尝试将上一位保存住）。

rox指令对OF、CF的影响都是同一个原则进行判断。rcx指令倒是特殊点，因为将CF也放入循环中。
其实OF使用的就是最高位和次高位的变化。
	100.
DATAS SEGMENT 
    A dw ?
DATAS ENDS
下面两条指令等价：
mov ax,A
mov ax,[a]
	101.I/O端口的编制方法：
一、与存储器统一的编制
二、存储器独立编制：I/O端口和存储器分别使用了相对独立的空间，这时候要想访问I/O端口就要使用专门的指令。
in al/ax，port
out port，al/ax
port（限制范围0-255）这个端口号又可以用直接、DX寄存器间接寻址来获取。不支持变址、基址、变量来表示port。
	102.主机与外设数据之间的传送：无条件传送（认为外设已经准备好，使用in、out指令进行传送），程序查询方式传送，中断传送，直接存储器传送方式DMA。
	103.
int 1是除法中断
int 3是断点中断
int 4是溢出中断，每一次溢出都会产生中断。
中断的时候指令执行顺序：
取中断向量（估计是把N放到寄存器里面）
pushf
call far ptr #先cs（4N+2）再IP（4N）
将IF=TF=0
	104.条件跳转指令后面只能直接跟标号，不能将地址传到寄存器，然后用寄存器来进行跳转。
	105.NOP \x90
	106.数据类型：
byte，word，dword，qword

.byte，.ascii，.asciz（以NULL结尾的字符串），.int（32位），.short（16位），.float，.double这一行是比如说C编译以后得到的汇编代码。这里面段也是.data这种写法。.global xx定义全局变量。
	107.sp是esp的低16位


在Real Mode下，我们对一个内存地址的访问是通过Segment:Offset的方式来进行的
到了Protected Mode，内存的管理模式分为两种，段模式和页模式，其中页模式也是基于段模式的。也就是说，Protected Mode的内存管理模式事实上是：纯段模式和段页式。（一个段的描述符需要规定对自身的访问权限）。所以，在Protected Mode下，对一个段的描述则包括3方面因素：【Base Address, Limit, Access】，它们加在一起被放在一个64-bit长的数据结构中，被称为段描述符。这种情况下，如果我们直接通过一个64-bit段描述符来引用一个段的时候，就必须使用一个64-bit长的段寄存器装入这个段描述符。但Intel为了保持向后兼容，将段寄存器仍然规定为16-bit（尽管每个段寄存器事实上有一个64-bit长的不可见部分，但对于程序员来说，段寄存器就是16-bit的，也就是段选择子），那么很明显，我们无法通过16-bit长度的段寄存器来直接引用64-bit的段描述符。
怎么办？解决的方法就是把这些长度为64-bit的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用（事实上，是将段寄存器中的高13 -bit的内容作为索引）。这个全局的数组就是GDT。事实上，在GDT中存放的不仅仅是段描述符，还有其它描述符，它们都是64-bit长。GDT是Protected Mode所必须的数据结构，也是唯一的。另外，正像它的名字（Global Descriptor Table）所揭示的，它是全局可见的，对任何一个任务而言都是这样。

GDTR是什么？
GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，CPU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。

LDT是什么？
除了GDT之外，IA-32还允许程序员构建与GDT类似的数据结构，它们被称作LDT（Local Descriptor Table，局部描述符表），但与GDT不同的是，LDT在系统中可以存在多个，并且从LDT的名字可以得知，LDT不是全局可见的，它们只对引用它们的任务可见，每个任务最多可以拥有一个LDT。另外，每一个LDT自身作为一个段存在，它们的段描述符被放在GDT中。
 LDT只是一个可选的数据结构，你完全可以不用它。使用它或许可以带来一些方便性，但同时也带来复杂性，如果你想让你的OS内核保持简洁性，以及可移植性，则最好不要使用它。

LDTR是什么？
IA-32为LDT的入口地址也提供了一个寄存器LDTR，因为在任何时刻只能有一个任务在运行，所以LDT寄存器全局也只需要有一个。如果一个任务拥有自身的LDT，那么当它需要引用自身的LDT时，它需要通过lldt指令将其LDT的段描述符装入此寄存器。lldt指令与lgdt指令不同的时，lgdt指令的操作数是一个32-bit的内存地址，这个内存地址处存放的是一个32-bit GDT的入口地址，以及16-bit的GDT Limit。而lldt指令的操作数是一个16-bit的选择子，这个选择子主要内容是：被装入的LDT的段描述符在GDT中的索引值。

至此，我们可以这样理解GDT和LDT：GDT为一级描述符表，LDT为二级描述符表。在GDT中有着指向LDT的指针。

由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问。

计算机由实模式进入到保护模式要加载gdt，保护模式下的段寄存器由16位的选择器与64位的段描述符寄存器构成。
段描述符寄存器： 存储段描述符；
选择器：存储段描述符的索引；
原先实模式下的各个段寄存器作为保护模式下的段选择器，80486中有6个(即CS,SS,DS,ES,FS,GS)16位的段寄存器
	108.INT n指令为2字节指令（机器码为11001101 ―n―，第2个字节就是中断向量号n），但向量号为3的指令中断（INT 3）是1字节指令（11001100），较特殊，常用做程序调试的断点中断。
	  程序员可以改变段地址和偏移地址，但是在这个过程中如果需要改变段寄存器SS和SP必须禁止中断，当改变完成后再恢复中断（也就是说在cli指令后需要有与其配对的sti指令，否则计算机--最常见的反应就是崩溃）




指令：
XCHG 用于通用寄存器之间，通用寄存器和存储器之间交换数据。这个指令操作多少位是要看其操作对象（中间的Temp存储可能是用了寄存器，也可能内存，这个看cpu制造商怎么设计的）
PUSH、POP系列操作多少位，是看他是什么指令或者是什么操作对象又或者是什么修饰：
	PUSH AX　　　　　　　　　　；通用寄存器操作数入栈(16位)
	PUSH EBX　　　　　　　　　 ；通用寄存器操作数入栈(32位)
	PUSH [SI]　　　　　　　　　；存储器操作数入栈(16位)
	PUSH DWORD PTR [DI]　　　　；存储器操作数入栈(32位)
	PUSHW 0A123H　　　　　　　 ；立即数入栈(16位) #立即数也是可以直接入栈，但是使用的是pushw指令。masm不支持。W是word的意思。
	PUSHD 20H　　　　　　　　　；立即数入栈(32位)
TEST ：
目的操作数和源操作数按位进行逻辑与操作，结果不回送目的操作数。常用来判断某一位是否为1.

地址传送指令：
LEA 将源操作数的偏移地址传到通用寄存器：
	LEA BX，BLOCK；将BLOCK的有效地址传送到BX中(16位)
　	LEA EAX，[EBX]；将EBX内容(有效地址)传送到EAX中(32位)
LDS(ES，FS，GS，SS)REG，MEM
　　功能：根据源操作数指定的偏移地址，在数据段中取出段地址和偏移地址分别送指定的段寄存器和指定的通用寄存器。
	LES BX，[SI]　　　　　　　　；将32位地址指针分别送ES和BX
	LSS EAX，[EDI]　　　　　　　；将48位地址指针分别送SS和EAX　　　
　　	LDS BX，DATA1；将buff的32位地址指针分别送DS和BX

标志寄存器传送指令
　　	(1) 格式：LAHF
　　　　　　　SAHF  L是load，S是store
　	功能：LAHF将标志寄存器中低8位送AH中。SAHF将AH中内容送标志寄存器中低8位。是对CF，PF，AF，ZF，SF的操控。
　　	(2) 格式：PUSHF
　　　　　　　POPF
　　	功能：PUSHF将标志寄存器低16位内容压入堆栈，SP←SP-2。POPF将当前栈顶一个字传送到标志寄存器低16位中，SP←SP+2。
　　	(3) 格式：PUSHFD
　　　　　　　POPFD
　　	功能：PUSHFD将标志寄存器32位内容压入堆栈SP←SP-4。POPFD将当前栈顶一个双字传送到32位标志寄存器中，SP←SP+4。

设计了CF的加减法：
ADC
SBB

除法：（乘法也是这样子，在前面加个i）
DIV SRC	无符号数除法

JMP的变种：
看单寄存器：
6个算术寄存器，除了AF没有。
JO
JNO
JZ/JE 是否等于/为0
JNZ/JNE
JS
JNS
JP/JPE
JNP/JPO
JC
JNC
无符号数比较条件转移指令：(使用CF或者ZF或者两者)
JA/JNBE
JAE/JNB
JE/JNE
JBE/JNA...
对于通用寄存器：（可以检测的就是cx）
JCXZ及其扩展JECXZ


对DF的控制：
CLD为清除方向标志，即将DF置‘0’。clear df
STD为设置方向标志，即将DF置‘1’。set df

imul 是有符号整数，支持的格式比mul多。下面就按照16位来解释
imul Reg16,Reg/Mem/IMM 将16位乘到Reg16上面去，如果乘积超过16位就把CF=OF=1。
imul Reg16, Mem16, IMM 将2,3参数相乘放入1
IDIV SRC有符号数除法
不过如果被除数与除数的位数不同的时候要要进行符号位扩展：
CBW 将Byte扩展到Word
CWD 将Word扩展到Dword（将ax扩展到dx）
CWDE 将AX扩展到EAX
CDQ 将EAX扩展到EDX
mov是对一个字的内容进行操作，这点和push以及pop一样。
CWD符号位扩展（对于8086，也就是把字转换为双字）ax的符号位扩展到dx
补充：符号位扩展不会对补码代表的值有影响。

TEST DEST，SRC
目的操作数和源操作数按位进行逻辑与操作，结果不回送目的操作数。源操作数可以为通用寄存器、存储器或立即数。目的操作数可以为通用寄存器或存储器操作数。

移位指令
mov cl,4;只能是cl。有时候可以ch与cx，是个意外。
shr ah,cl

循环移位指令
　　格式：ROL DEST，OPRD
　　　　　ROR DEST，OPRD
　　　　　RCL DEST，OPRD///下面这两个是带进位CF的，就是循环的时候要不要把它算进去
　　　　　RCR DEST，OPRD
　　功能：循环左移指令ROL，见图313(a)所示，目的操作数左移，每移位一次，其最高位移入最低位，同时最高位也移入进位标志CF。循环右移指令 ROR见图313(b)所示，目的操作数右移，每移位一次，其最低位移入最高位，同时最低位也移入进位标志CF。

CLC。功能：清除进位标志。
STC。功能：设置进位标志。
CMC。功能：进位标志取反。
CLI 屏蔽中断
STI 开启中断

HLT(Halt 停机指令)
暂停程序的执行。当产生一个外部中断或非屏蔽中断时，才继续执行下一条指令。不过书上说：切断CPU时钟输入，是系统停机，要使用RESET复位信号才可以再启动系统。

WAIT
检查BUSY引脚状态，等待协处理器完成当前工作。


ret 6表示ret之后add sp,6
RETN   操作数1
RETF
RETF   操作数1
RETN等价于一条指令：POP   ip（相当于ret）
RETF等价于两条指令：
POP   ip
POP   CS
而带有操作数的RETN/RETF指令则是在POP（ESP+4）之后，执行ESP=ESP+操作数1

func proc far ;没有冒号
	ret ;实际指令就会使retf
func endp

word ptr后跟地址或者ax，bx，cx，dx等寄存器

loop function这种用法有点坑。首先，他并不等于执行“call function ”cx次，所以应该把call函数调用放在loop的循环标号中，因为我发现这种语句没有保存ip（基本cs段不会变，看的就是ip），所以你要自己push与pop寄存器，然后jmp回到原函数而不是ret类命令。
loopz/loope 让跳转增加zf=1的条件
loopnz/loopne 让跳转增加zf=0的条件


POPF指令将保护的FLAG内容恢复.它将堆栈内栈顶字单元的内容弹出到标志寄存器中。所以后面没有参数。

call指令详解：（传地址方式结合近转移的一个字或者远转移的两个字）
近转移：
call 标号（具体怎么样就要看子程序性质了，ret、jmp也是这样，具体看子程序性质）
call near ptr 标号
call 16位 reg
call word ptr 内存单元地址
远转移：
call far ptr 标号 #先存CS再存IP，注意设置栈空间和SP。
call dword ptr 内存单元地址
call short ptr function这条指令是不存在的

目前我所知的唯一内存到内存的操作：
movsb 的功能是将 ds:si 指向的内存单元中的字节送入 es:di中，然后根据标志寄存器DF位的值，将 si和di递增或递减。默认，递增。
当然，也可以传送一个字， movsw指令
 

push是先sp-2，然后将数据存进去。栈顶是指向有效元素的！


NEG DH 相当于 用 0 减 DH来取补。所以可以推算出来对标志寄存器的影响。

非组合型（或者说非压缩）指令：
加法：
AAA代表ASCII Adjust After Addition。如果AL(3-0位)大于9或辅助进位AF=1，则AH=AH+01H，AL=AL+06H，且置AF和CF为1；否则置AF和CF为零。AL(7-4)=0。
减法：
AAS 减了以后如果值大于9或者AF=1，那么就再减掉6（都是为了略过10进制与16进制之间的差）
乘法：
AAM
除法：
AAD

组合型：
加法：
DAA用于对两个组合型BCD码进行相加的加法指令之后。对存放在AL中的和进行调整。将调整后的BCD码继续放在AL中。如果第四位>9或者AF=1，那么就会将AL+=6，且AF=1。如果AL的高四位大于9或者CF=1，就AL+=60H且CF=1。不属于上面两者的情况就AF=0，CF=0.
DAS ‘’同理。


128个字单元起始地址是12AB:00AB，问末字节地址：
中间有127个字节，所以(128-1)x2=FE  而不是128x2-1
12AB0+AB+FE就是答案


串操作类指令：
[LABEL:] [repeat prefix]串操作指令
LODS 取串指令。从串中取出一个字节、字、双字放到AL，AX，EAX。
STOS 存串指令。
MOVS 串传送指令。从串（在内存上面）放到内存的另一个区域（ds;si->es:di）。
CMPS 串比较指令。
SCAS ds:si和al、ax、eax进行比较。
INS  从口（PORT）地址读取串，读取放到内存。
OUTS
上面的指令后面可以跟着B，W，D。或者使用ptr进行类型指定。
lodsw
lods word ptr [si]
lods w ;w定义为word属性的符号地址

重复前缀：
REP
REPZ/REPE (类似于loopz)
REPNZ/REPNE
上面两行指令倒是经常和scas指令合用。

test 会改变值的and

